<script>

  class Dep {//means dependency
    constructor() {
      this.subscribers = []//it's a storage for subsribers, according to observer pattern
    }
    //instead of record() on main branch - to save target:
    depend() {
      if (target && !this.subscribers.includes(target)){
        this.subscribers.push(target)
      }
    }
    //instead of replay() on main branch: 
    notyfy() {
      this.subscribers.forEach(sub => sub())
    }
  }
  //instead of this:

  // const dep = new Dep();  
  // let price = 5;
  // let quantity = 2;

  //implementing this more scalable variant:
  let data = { price: 5, quantity: 2 }
  let total, target, sapePrice;

  //in order to figure out, which property was changed:
  Object.keys(data).forEach(key => {
    let internalValue = data[key];
    const dep = new Dep();
    Object.defineProperty(data, key, {
      get() {
        dep.depend()
        console.log(`I was accesed: ${key} : ${internalValue}`)
        return internalValue;
      },
       set(newVal) {
        console.log(`I was changed: ${key} to ${newVal}`)
        internalValue = newVal;
        dep.notyfy()
      }
    }) 
  })
  
  let watcher = (myFunc) => {
    target = myFunc;
    target();
    target = null;
  }
  watcher(() => {
     total = data.price * data.quantity;
  })
  watcher(() => {
     salePrice = data.price * 0.9;
  })
  
</script>
